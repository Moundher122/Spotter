# Spotter v2 — Technical Documentation

### Steps 1, 2, and 4 — Same as v1

- `geocoding.geocode()` — identical to v1 (see [v1.md](v1.md)).
- `provider_call.get_route()` — identical to v1 (see [v1.md](v1.md)).
- `optimizer.optimize_fuel_stops()` — identical DP algorithm (see [v1.md](v1.md)). The optimizer still uses projected distances internally; v2 only changes how those distances are computed (step 3) and validates the final output with a second routing call (step 5).

---

### 3. `stations.get_stations_along_route_v2(route_points, cumulative_distances)` → `list[dict]`

Finds gas stations near the route and assigns each a `distance_from_start` using **perpendicular segment projection** instead of v1's nearest-point lookup.

#### Algorithm — Segment Projection

Steps 1–3 (bounding box, DB query, sub-sampling) are identical to v1.

**Step 4 is different:**

For each station, iterate through consecutive **pairs** of sampled route points (segments A→B):

1. **Pre-filter**: Build a rectangular bounding box around the segment expanded by 0.4°/0.5°. Skip the segment entirely if the station is outside this box.

2. **Project** the station onto segment A→B using `project_point_onto_segment()`.

3. **Interpolate** the cumulative distance at the projection point.

4. **Track** the segment that gives the smallest perpendicular distance.

#### `project_point_onto_segment(p_lat, p_lng, a_lat, a_lng, b_lat, b_lng)` → `(t, proj_lat, proj_lng)`

Projects point P perpendicularly onto the line segment A→B.

**How it works:**

1. Compute the middle latitude of the segment: `mid_lat = (a_lat + b_lat) / 2`

2. Scale longitude by `cos(mid_lat)` to correct for meridian convergence. Without this, 1° of longitude near the equator (≈69 mi) would be treated the same as 1° near the poles (≈0 mi). The correction makes the flat-earth approximation accurate at the segment's latitude:
   ```
   dx = (b_lng - a_lng) × cos(mid_lat)
   dy = b_lat - a_lat
   ```

3. Do the same for the station-to-A vector:
   ```
   px = (p_lng - a_lng) × cos(mid_lat)
   py = p_lat - a_lat
   ```

4. Compute the projection parameter `t` using the dot product formula:
   ```
   t = (px·dx + py·dy) / (dx² + dy²)
   ```
   This is the standard scalar projection of vector AP onto vector AB, normalized by |AB|².

5. Clamp `t` to [0, 1] so the projection stays on the segment (not beyond its endpoints).

6. Compute the projected coordinates:
   ```
   proj_lat = a_lat + t × (b_lat - a_lat)
   proj_lng = a_lng + t × (b_lng - a_lng)
   ```

**Distance interpolation:**

Once `t` is known, the cumulative distance at the projection point is:

```
distance_from_start = cum_A + t × (cum_B - cum_A)
```

This linearly interpolates between the cumulative distances of the segment endpoints. Since sub-sampled segments are short (~1–2 miles), the linear assumption introduces negligible error.

#### Why this is more accurate than v1

In v1, a station's `distance_from_start` snaps to the **nearest sampled point**. If sampled points are 1.5 miles apart and the station sits halfway between two points, v1 could be off by ~0.75 miles.

V2 projects onto the **segment** between the two points and interpolates, giving sub-mile accuracy. On a 2,800-mile cross-country route, this eliminates systematic rounding in station ordering and DP gap calculations.

---

### 5. `provider_call.get_route_with_waypoints(waypoints)` → `dict`

Makes the **second** (and final) OSRM call — routing through the actual fuel stop locations.

**OSRM call:**
```
GET /route/v1/driving/{start};{stop1};{stop2};...;{end}?overview=full&geometries=polyline
```

Where each coordinate is `lng,lat`.

**Input:** Ordered list of `(lat, lng)` tuples: `[start, stop₁, stop₂, …, end]`

**Returns:**
| Key | Type | Description |
|-----|------|-------------|
| `route_polyline` | `str` | Encoded polyline of the full waypoint route |
| `total_distance_miles` | `float` | Real driving distance including detours (OSRM meters → miles) |

#### Why a second call is needed

The DP optimizer works on **projected** distances — the station is treated as sitting directly on the base route. In reality, a station might be 5 miles off the highway. The second OSRM call routes through the actual station coordinates, giving:

- **Real total distance** that accounts for detours to reach each station.
- **Production-ready polyline** that a frontend can draw on a map, showing the actual path the truck would drive.

#### No-stops case

If the DP optimizer returns zero fuel stops (route ≤ max_range), the second call is skipped. The base route's polyline and distance are used directly.

---

## Constraints

- **Exactly 2 OSRM calls** per request — no per-station routing.
- The DP optimizer is **unchanged** from v1 — it still uses projected distances internally. The second route call is only for final output accuracy.
- `total_fuel_cost` and `total_gallons` come from the DP result (projected distances), not the validated route distance. This is intentional: the cost optimization is done on the projected graph, and the validated distance is for display only.

---

## Configuration

Same as v1 — see `spotter/settings.py` under `FUEL_OPTIMIZER`.
